## 저장소
원격 저장소와 로컬 저장소로 나뉜다.

로컬 저장소에서 commit을 하며, 형상을 관리한다.
그러다가 현재 저장소를 원격 저장소로 push를 하며, 다른 사람들과 함께 협업을 할 수 있다.

## 브랜치
원격 저장소와 로컬 저장소 각각이 브랜치를 가진다.
현재 로컬 저장소에서 브랜치를 따로 사용하면서 저장소를 관리한다.
그러다가 로컬 저장소 내용을 원격 저장소에 push할 때, 원격 저장소 중 어느 브랜치에 push할지 선택하면서 다른 사람들과 협업할 수 있다.

예를 들어, 각각 특정 기능에 대해서 개발하고 원격 저장소에 각각 다른 브랜치에 소스코드를 push하면 된다.
이후에 각각 브랜치를 한개로 합치는 작업만 하게 된다면, 효율적인 협업이 가능해진다.

** 운영서버와 개발서버는 브랜치를 따로 관리하는게 아닌, 별도로 저장소를 관리할지도 모른다. 실제 현업에서는 어떻게 사용될지 모르겠다.

## SVN 과 Git 차이
SVN은 특정 파일의 바뀐 내용에 대해서만 저장한다.
Git은 특정 파일의 바뀐 내용만 저장하는게 아닌, 파일 전체를 저장한다.

SVN이 당장 작은 프로젝트에서 용량 관리나 성능 면에서 효율적일 수 있다.
하지만, 프로젝트 규모가 커진다면 Git이 더 좋다.

첫 번째 형상과 백 번째 형상을 비교 시,
SVN은 100번에서 1번까지 전부 되돌아가며, 각각 파일에 대한 형상을 원상복구 해나간다.
Git은 1번과 100번을 정확하게 지정해서 비교한다. 그러니 연산 속도는 Git이 훨씬 빠르며, 용량적인 측면에서는 비효율적일지 몰라도 복잡한 계산에서 더 단순하게 계산할 수 있다.

## Git은 모든 파일을 저장한다.
당장 변하지 않은 파일들도 형상을 통째로 저장한다.


# 여러 명이 함께 Git으로 협업하기
Git은 서로의 작업물에 의존하지 않고 내가 원할 때 코드를 올리고, 또 내가 원할 때 협업자의 코드와 합칠 수 있다.

## 브랜치 관리
브랜치는 특정 팀이나 사람 별로 생성해서 사용하면 된다. 각자가 맡은 기능 별로 해당 브랜치에서 개발하면서 나중에 특정 브랜치에서 합치면 된다. 합치는 방법은 합치고자 하는 브랜치에서 병합을 누르면 된다. 그러면 합쳐진다.

만약 소스코드에서 충돌(conflict)가 발생한다면, commit을 할 수 없다. 그런데 현재 충돌난 소스코드는 내 파일들에 반영되어있다. 여기서 충돌난 소스코드만 수정 후, commit하면 된다. 그러면 병합이 완료된거다.

참고로 master 브랜치는 건드리지 않는다. 원격저장소 master 브랜치에 내 코드를 넣고 싶다면, pull request를 통해서 요청해야한다. 왜냐하면, 해당 프로젝트에서 기준이 되는 정보를 조또 모르는 신입이 건드리면 빡치지 않겠는가. 여튼 이때, 내 원격저장소 브랜치에서 모든 내용들을 push하고나서 마지막에 master 브랜치에 pull request를 보내면 된다.

master 브랜치 담당자가 pull request를 허용했다면, 원격저장소 master 브랜치와 연동된 로컬저장소 master 브랜치는 pull 해줘야한다. 그래야 로컬저장소까지 반영된다. 사실 소스트리 기본 설정에서는 약 10분 주기마다 자동으로 fetch(history 다운로드) 해주기는 한다. (소스코드는 변경되지 않음.) 그렇기에 변경된 사항이 있다면 확인후, pull을 해주면 된다.

## 배포
프로그램 배포 또한 가능한데, 배포를 릴리즈라고 한다. 이 릴리즈 버전 역시 태그로 관리가 가능하다. 태그 추가하고, push하면 쉽게 다운받아 볼 수 있다. 태그 관리는 'v1.0.0', 'v1.0.1' 과 같이 하면 된다.

# 둘 이상의 원격저장소로 협업하기


## fork
원본저장소를 복사해서 Git 저장소를 새롭게 만든다. 원본저장소에 권한이 없는 사람이 해당 소스코드를 함께 수정하고 싶다면, fork를 통해서 소스코드 수정을 하면서 프로젝트에 참여가 가능하다.

원본저장소를 직접 건드릴 수 있는 사람은 본인 뿐이다. 혹은 협력자로 등록해야만 함께 사용이 가능하다. 협력자 등록방법은 settings - collaborators에 들어가서 Add collaborator를 클릭하면 가능하다.

사실 협력자가 많이 생기면 원본저장소를 관리하기 귀찮아진다.


## fork vs branch
branch는 원본저장소 한 곳에서 여러 분기(branch)를 관리한다.
하나의 원본저장소에서 코드 커밋 이력을 편하게 볼 수 있다. 사용자가 많아지면 branch가 많아지므로, 관리하기가 힘들어진다. branch는 해당 원본 저장소에 권한이 있다.

fork는 원본저장소를 복제하여 새로운 원격저장소에서 프로젝트를 진행할 수 있다.
원본저장소에 영향을 미치지 않으므로 원격저장소에서 마음껏 코드를 수정할 수 있다. 원본저장소의 이력을 보려면 따로 주소를 추가해야한다. fork는 해당 원본 저장소에 대한 권한이 없다. 오직 pull request를 통해서 원본 저장소 주인한테 부탁해야한다.


## 기여도
pull request를 하게 된다면, 각 협력자에 대한 기여도를 확인할 수 있다. (Insight - collaborator)

## 강제 push는 하지 말자.
push할 때, 에러가 발생하면서 push가 안될 수 있다. 이럴 때, 강제 push를 하면 push가 되기는 한다. 하지만, 이 상황 속에서 에러가 발생할 수도 있다. 그렇기에 강제 push를 하지 않는 걸 권장하는 블로거가 있었다. 이 경우, pull을 통해서 소스코드를 새롭게 다운받은 후 push할 것을 권장했다.


# 묵은 커밋을 새 커밋으로 이력 조작하기 (rebase)
2개 이상 저장소를 로컬 저장소에서 추적해야 한다. (2개 이상 저장소 = 원본 저장소 + 현재 Git 저장소) 이 때, 원본 저장소는 upstream으로 지정한다.(관용적으로 보통 원본 저장소를 upstream 이라고 사용)

rebase는 반드시 혼자만 사용하는 브랜치에서 사용해야 한다. 보통 기능 구현을 하는 브랜치는 혼자만 쓰니까 편하게 rebase해도 된다.

원본저장소와 fork저장소는 똑같은 커밋을 기준으로 같은 소스코드를 수정했다면, 충돌이 발생한다. 이럴 경우, rebase를 사용해야 한다.



## pull vs fetch
pull은 소스코드와 history 모두 가져온다.
fetch는 저장소에서 history만 가져온다.


## 혼자서 형상 관리 vs 여러 명이서 형상 관리
혼자서 형상 관리를 한다면, 단순하게 branch를 통해서 형상을 관리해도 된다. 사실 branch 조차 사용하지 않고, 형상을 관리할 수도 있다.

여러 명이서 형상을 관리한다면 이야기는 달라진다. 여러 명이서 형상을 관리할 경우, fork & pull request를 활용하여 버전을 관리하는게 좋다.